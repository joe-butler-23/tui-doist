import { type TExtendsAny } from './any.mjs';
import { type TExtendsArray } from './array.mjs';
import { type TExtendsAsyncIterator } from './async-iterator.mjs';
import { type TExtendsBigInt } from './bigint.mjs';
import { type TExtendsBoolean } from './boolean.mjs';
import { type TExtendsConstructor } from './constructor.mjs';
import { type TExtendsEnum } from './enum.mjs';
import { type TExtendsFunction } from './function.mjs';
import { type TExtendsInteger } from './integer.mjs';
import { type TExtendsIntersect } from './intersect.mjs';
import { type TExtendsIterator } from './iterator.mjs';
import { type TExtendsLiteral } from './literal.mjs';
import { type TExtendsNever } from './never.mjs';
import { type TExtendsNull } from './null.mjs';
import { type TExtendsNumber } from './number.mjs';
import { type TExtendsObject } from './object.mjs';
import { type TExtendsPromise } from './promise.mjs';
import { type TExtendsString } from './string.mjs';
import { type TExtendsSymbol } from './symbol.mjs';
import { type TExtendsTemplateLiteral } from './template-literal.mjs';
import { type TExtendsTuple } from './tuple.mjs';
import { type TExtendsUndefined } from './undefined.mjs';
import { type TExtendsUnion } from './union.mjs';
import { type TExtendsUnknown } from './unknown.mjs';
import { type TExtendsVoid } from './void.mjs';
import { type TAny } from '../types/any.mjs';
import { type TArray } from '../types/array.mjs';
import { type TAsyncIterator } from '../types/async-iterator.mjs';
import { type TBigInt } from '../types/bigint.mjs';
import { type TBoolean } from '../types/boolean.mjs';
import { type TConstructor } from '../types/constructor.mjs';
import { type TEnum, type TEnumValue } from '../types/enum.mjs';
import { type TFunction } from '../types/function.mjs';
import { type TInteger } from '../types/integer.mjs';
import { type TIntersect } from '../types/intersect.mjs';
import { type TIterator } from '../types/iterator.mjs';
import { type TLiteral } from '../types/literal.mjs';
import { type TNever } from '../types/never.mjs';
import { type TNull } from '../types/null.mjs';
import { type TNumber } from '../types/number.mjs';
import { type TObject } from '../types/object.mjs';
import { type TPromise } from '../types/promise.mjs';
import { type TSchema } from '../types/schema.mjs';
import { type TString } from '../types/string.mjs';
import { type TSymbol } from '../types/symbol.mjs';
import { type TTemplateLiteral } from '../types/template-literal.mjs';
import { type TTuple } from '../types/tuple.mjs';
import { type TUndefined } from '../types/undefined.mjs';
import { type TUnknown } from '../types/unknown.mjs';
import { type TProperties } from '../types/properties.mjs';
import { type TUnion } from '../types/union.mjs';
import { type TVoid } from '../types/void.mjs';
import * as Result from './result.mjs';
export type TExtendsLeft<Inferred extends TProperties, Left extends TSchema, Right extends TSchema> = (Left extends TAny ? TExtendsAny<Inferred, Left, Right> : Left extends TArray<infer Type extends TSchema> ? TExtendsArray<Inferred, Type, Right> : Left extends TAsyncIterator<infer Type extends TSchema> ? TExtendsAsyncIterator<Inferred, Type, Right> : Left extends TBigInt ? TExtendsBigInt<Inferred, Left, Right> : Left extends TBoolean ? TExtendsBoolean<Inferred, Left, Right> : Left extends TConstructor<infer Parameters extends TSchema[], infer InstanceType extends TSchema> ? TExtendsConstructor<Inferred, Parameters, InstanceType, Right> : Left extends TEnum<infer Values extends TEnumValue[]> ? TExtendsEnum<Inferred, TEnum<Values>, Right> : Left extends TFunction<infer Parameters extends TSchema[], infer ReturnType extends TSchema> ? TExtendsFunction<Inferred, Parameters, ReturnType, Right> : Left extends TInteger ? TExtendsInteger<Inferred, Left, Right> : Left extends TIntersect<infer Types extends TSchema[]> ? TExtendsIntersect<Inferred, Types, Right> : Left extends TIterator<infer Type extends TSchema> ? TExtendsIterator<Inferred, Type, Right> : Left extends TLiteral ? TExtendsLiteral<Inferred, Left, Right> : Left extends TNever ? TExtendsNever<Inferred, Left, Right> : Left extends TNull ? TExtendsNull<Inferred, Left, Right> : Left extends TNumber ? TExtendsNumber<Inferred, Left, Right> : Left extends TObject<infer Properties extends TProperties> ? TExtendsObject<Inferred, Properties, Right> : Left extends TPromise<infer Type extends TSchema> ? TExtendsPromise<Inferred, Type, Right> : Left extends TString ? TExtendsString<Inferred, Left, Right> : Left extends TSymbol ? TExtendsSymbol<Inferred, Left, Right> : Left extends TTemplateLiteral<infer Pattern extends string> ? TExtendsTemplateLiteral<Inferred, Pattern, Right> : Left extends TTuple<infer Types extends TSchema[]> ? TExtendsTuple<Inferred, Types, Right> : Left extends TUndefined ? TExtendsUndefined<Inferred, Left, Right> : Left extends TUnion<infer Types extends TSchema[]> ? TExtendsUnion<Inferred, Types, Right> : Left extends TUnknown ? TExtendsUnknown<Inferred, Left, Right> : Left extends TVoid ? TExtendsVoid<Inferred, Left, Right> : Result.TExtendsFalse);
export declare function ExtendsLeft<Inferred extends TProperties, Left extends TSchema, Right extends TSchema>(inferred: Inferred, left: Left, right: Right): TExtendsLeft<Inferred, Left, Right>;
