// deno-fmt-ignore-file
import { Guard, GlobalsGuard } from '../../guard/index.mjs';
import * as T from '../../type/index.mjs';
import { FromArray } from './from-array.mjs';
import { FromBase } from './from-base.mjs';
import { FromEnum } from './from-enum.mjs';
import { FromIntersect } from './from-intersect.mjs';
import { FromObject } from './from-object.mjs';
import { FromRecord } from './from-record.mjs';
import { FromRef } from './from-ref.mjs';
import { FromTemplateLiteral } from './from-template-literal.mjs';
import { FromTuple } from './from-tuple.mjs';
import { FromUnion } from './from-union.mjs';
import { FromUnknown } from './from-unknown.mjs';
import { RepairError } from './error.mjs';
// ------------------------------------------------------------------
// AssertRepairableValue
// ------------------------------------------------------------------
function AssertRepairableValue(context, type, value) {
    const unsupported = GlobalsGuard.IsDate(value)
        || GlobalsGuard.IsMap(value)
        || GlobalsGuard.IsSet(value)
        || GlobalsGuard.IsTypeArray(value)
        || Guard.IsConstructor(value)
        || Guard.IsFunction(value);
    if (unsupported) {
        throw new RepairError(context, type, value, 'Value is not repairable');
    }
}
// ------------------------------------------------------------------
// AssertRepairableType
// ------------------------------------------------------------------
function AssertRepairableType(context, type, value) {
    const unsupported = T.IsAsyncIterator(type)
        || T.IsIterator(type)
        || T.IsConstructor(type)
        || T.IsFunction(type)
        || T.IsNever(type)
        || T.IsPromise(type);
    if (unsupported) {
        throw new RepairError(context, type, value, 'Type is not repairable');
    }
}
// ------------------------------------------------------------------
// FromType
// ------------------------------------------------------------------
export function FromType(context, type, value) {
    // Intercept Base
    if (T.IsBase(type))
        return FromBase(context, type, value);
    // Standard Repair
    AssertRepairableValue(context, type, value);
    AssertRepairableType(context, type, value);
    return (T.IsArray(type) ? FromArray(context, type, value) :
        T.IsEnum(type) ? FromEnum(context, type, value) :
            T.IsIntersect(type) ? FromIntersect(context, type, value) :
                T.IsObject(type) ? FromObject(context, type, value) :
                    T.IsRecord(type) ? FromRecord(context, type, value) :
                        T.IsRef(type) ? FromRef(context, type, value) :
                            T.IsTemplateLiteral(type) ? FromTemplateLiteral(context, type, value) :
                                T.IsTuple(type) ? FromTuple(context, type, value) :
                                    T.IsUnion(type) ? FromUnion(context, type, value) :
                                        FromUnknown(context, type, value));
}
