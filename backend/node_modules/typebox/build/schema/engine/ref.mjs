// deno-fmt-ignore-file
import * as F from './_functions.mjs';
import * as S from '../types/index.mjs';
import { Guard as G } from '../../guard/index.mjs';
import { CheckSchema, ErrorSchema } from './schema.mjs';
import { Deref } from '../deref/index.mjs';
// ------------------------------------------------------------------
// Resolve
// ------------------------------------------------------------------
function Resolve(context, schema) {
    // note: it is safe to coerce to XSchema here as it wouldn't be possible
    // to enter a ref resolution if the root schema was boolean.
    const schemaRoot = context.GetSchema();
    // contextual schema
    const schemaContext = context.GetContext();
    if (G.HasPropertyKey(schemaContext, schema.$ref)) {
        return schemaContext[schema.$ref];
    }
    // inline referential schema
    const dereferenced = Deref(schemaRoot, { $ref: schema.$ref });
    return S.IsSchemaLike(dereferenced) ? dereferenced : false;
}
// ------------------------------------------------------------------
// Build
// ------------------------------------------------------------------
export function BuildRef(context, schema, value) {
    const target = Resolve(context, schema);
    return F.CreateFunction(context, target, value);
}
// ------------------------------------------------------------------
// Check
// ------------------------------------------------------------------
export function CheckRef(context, schema, value) {
    const target = Resolve(context, schema);
    return (S.IsSchemaLike(target) && CheckSchema(context, target, value));
}
// ------------------------------------------------------------------
// Error
// ------------------------------------------------------------------
export function ErrorRef(context, schemaPath, instancePath, schema, value) {
    const target = Resolve(context, schema);
    return (S.IsSchemaLike(target) && ErrorSchema(context, '#', instancePath, target, value));
}
