import * as S from '../types/index.mjs';
import type { TValidationError } from '../../error/index.mjs';
export declare function HasUnevaluated(context: Record<PropertyKey, unknown>, schema: unknown): boolean;
export declare class BaseContext {
    protected readonly context: Record<PropertyKey, S.XSchemaLike>;
    protected readonly schema: S.XSchemaLike;
    constructor(context: Record<PropertyKey, S.XSchemaLike>, schema: S.XSchemaLike);
    GetContext(): Record<PropertyKey, object | boolean>;
    GetSchema(): object | boolean;
}
export declare class BuildContext extends BaseContext {
    private readonly hasUnevaluated;
    constructor(context: Record<PropertyKey, S.XSchemaLike>, schema: S.XSchemaLike, hasUnevaluated: boolean);
    UseUnevaluated(): boolean;
    AddIndex(index: string): string;
    AddKey(key: string): string;
    Clone(): string;
    Merge(results: string): string;
}
export declare class CheckContext extends BaseContext {
    private readonly indices;
    private readonly keys;
    constructor(context: Record<PropertyKey, S.XSchemaLike>, schema: S.XSchemaLike);
    AddIndex(index: number): true;
    AddKey(key: string): true;
    GetIndices(): Set<number>;
    GetKeys(): Set<string>;
    Clone(): CheckContext;
    Merge(results: CheckContext[]): true;
}
export type ErrorContextCallback = (error: TValidationError) => unknown;
export declare class ErrorContext extends CheckContext {
    private readonly callback;
    constructor(context: Record<PropertyKey, S.XSchemaLike>, schema: S.XSchemaLike, callback: ErrorContextCallback);
    AddError(error: TValidationError): false;
}
export declare class AccumulatedErrorContext extends ErrorContext {
    private readonly errors;
    constructor(context: Record<PropertyKey, S.XSchemaLike>, schema: S.XSchemaLike);
    AddError(error: TValidationError): false;
    GetErrors(): TValidationError[];
}
