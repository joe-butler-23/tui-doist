// deno-fmt-ignore-file
import { Guard as G, EmitGuard as E } from '../../guard/index.mjs';
import { AccumulatedErrorContext } from './_context.mjs';
import { BuildSchema, CheckSchema, ErrorSchema } from './schema.mjs';
import { Reducer } from './_reducer.mjs';
// ------------------------------------------------------------------
// Build
// ------------------------------------------------------------------
function BuildAnyOfStandard(context, schema, value) {
    return Reducer(context, schema.anyOf, value, E.IsGreaterThan(E.Member('results', 'length'), E.Constant(0)));
}
function BuildAnyOfFast(context, schema, value) {
    return E.ReduceOr(schema.anyOf.map((schema) => BuildSchema(context, schema, value)));
}
export function BuildAnyOf(context, schema, value) {
    return context.UseUnevaluated()
        ? BuildAnyOfStandard(context, schema, value)
        : BuildAnyOfFast(context, schema, value);
}
// ------------------------------------------------------------------
// Check
// ------------------------------------------------------------------
export function CheckAnyOf(context, schema, value) {
    const results = schema.anyOf.reduce((result, schema, index) => {
        const nextContext = context.Clone();
        return CheckSchema(nextContext, schema, value) ? [...result, nextContext] : result;
    }, []);
    return G.IsGreaterThan(results.length, 0) && context.Merge(results);
}
// ------------------------------------------------------------------
// Error
// ------------------------------------------------------------------
export function ErrorAnyOf(context, schemaPath, instancePath, schema, value) {
    const failedContexts = [];
    const results = schema.anyOf.reduce((result, schema, index) => {
        const nextContext = new AccumulatedErrorContext(context.GetContext(), context.GetSchema());
        const nextSchemaPath = `${schemaPath}/anyOf/${index}`;
        const isSchema = ErrorSchema(nextContext, nextSchemaPath, instancePath, schema, value);
        if (!isSchema)
            failedContexts.push(nextContext);
        return isSchema ? [...result, nextContext] : result;
    }, []);
    const isAnyOf = G.IsGreaterThan(results.length, 0) && context.Merge(results);
    if (!isAnyOf)
        failedContexts.forEach(failed => failed.GetErrors().forEach(error => context.AddError(error)));
    return isAnyOf || context.AddError({
        keyword: 'anyOf',
        schemaPath,
        instancePath,
        params: {}
    });
}
